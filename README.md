# C++基础

## 1.简单说一下C++的继承，封装和多态

* 封装：将一个模块的内部数据或操作隐藏起来，其他程序只能通过该模块提供的公开操作来访问他们的保护措施称为信息隐藏。而将这一组数据与这些数据上的相关操作组织在一起的措施称为封装。
* 继承：在一个或若干个已知类的基础上，经过适当的修改，扩充构成一个新类，该类具有原来作为基础的类的特征。
* 多态：在程序中同一符号或名字在不同的情况下具有不同解释的现象称为多态性。编译时多态：通过重载机制获得，包括函数重载和运算符重载；运行时多态：通过继承结合虚函数的动态绑定获得。

## 2.虚函数和虚表

* 虚函数：在一个类中用保留字Virtual定义的成员函数。
* 虚表：虚函数表里是函数指针，指向虚函数的指针。就是C++编译器实现运行时多态的封装。

## 3.什么时候和为什么要用虚析构

首先什么是虚析构，虚析构就是析构函数为虚函数。
那么为什么要用虚析构呢，是为了delete基类指针指向派生类时防止子类得数据不会被释放造成内存泄露。

## 4.纯虚函数

在基类中声明但又没有定义的虚函数。

## 5.函数重载(overload)和函数重写(override)

* 函数重载：在声明函数原型时形参的个数不同或者相同个数的参数但对应位置的参数类型不同，两个或多个函数可以共用同一个名字。
* 函数重写：即重定义，意思是在派生类中定义一个函数原型与继承成员一模一样的成员函数。

## 6.引用与指针的区别

* 初始化要求不同。引用在创建的同时必须初始化，即引用到一个有效的对象；而指针在定义的时候不要求初始化，可以在定义后面的任何地方重新赋值。
* 可修改性不同。引用一旦被初始化为指向一个对象，他就不能被改变为另一个对象的引用；而指针在任何时候都可以改变为指向另一个对象。
* 不存在NULL的引用，它必须总是指向某个对象；指针可以是NULL，不需要总是指向某些对象。

## 7.深拷贝与浅拷贝

* 深拷贝与浅拷贝最本质的区别在于是否真正获取到一个对象的复制实体，而不是引用。
* 浅拷贝只是复制指向某个对象的指针，而不是复制对象本身，新旧对象还是共享同一块内存。
* 深拷贝会创造一个一模一样的对象，新对象与原对象不共享内存，修改新对象不会改变原对象的值。

## 8.new和delete(new[] 和 delete [])

## 9.智能指针以及智能指针的实现，引用计数、RAII（资源获取即初始化）思想

* 智能指针的基本思想就是以栈对象管理资源，在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。引用计数是为了防止内存泄露而产生的，基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。
* unique_ptr: 它对对象持有独有权，两个unique_ptr不能指向同一个对象，不共享其管理的对象，无法复制到其他unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何STL算法，只能移动unique_ptr，对资源管理权实现转移，原始的unique_ptr不再拥有此资源。
* shared_ptr:允许多个指针指向同一个对象，其利用引用计数的方式实现了对所管理的对象所有权的分享，允许多个shared_ptr共同管理同一个对象。
* weak_ptr:可以从一个shared_ptr或者另一个weak_ptr对象构造而来，最大的作用在于协助shared_ptr工作，可获得资源得观测权，只是对shared_ptr 的引用，不改变其引用计数，当被观察的shared_ptr 失效后，相应的weak_ptr也会失败。

## 10.const的使用

## 11.static的使用

## 12.string的实现（实现构造、析构、拷贝构造、赋值操作符）

## 13.编译链接机制、内存布局（memory layout）、对象模型

* 编译链接阶段主要分为预处理、编译、汇编、链接这几个阶

  1、预处理（preprocessor）：对#include、#define、#ifdef/#endif、#ifndef/#endif等进行处理 ;
  2、编译（compiler）：将源码编译为汇编代码 ;
  3、汇编（assembler）：将汇编代码汇编为目标代码 ;
  4、链接（linker）：将目标代码链接为可执行文件 ;

* 可执行程序中的变量在内存中的布局可以总结为如下：

  变量（函数外）：如果未初始化，则存放在BSS段；否则存放在data段

  变量（函数内）：如果没有指定static修饰符，则存放在栈中；否则同上

  常量：存放在文本段.text

  函数参数：存放在栈或寄存器中

  内存可以分为以下几段：

  文本段：包含实际要执行的代码（机器指令）和常量。它通常是共享的，多个实例之间共享文本段。文本段是不可修改的。

  初始化数据段：包含程序已经初始化的全局变量，.data。

  未初始化数据段：包含程序未初始化的全局变量，.bbs。该段中的变量在执行之前初始化为0或NULL。

  栈：由系统管理，由高地址向低地址扩展。

  堆：动态内存，由用户管理。通过malloc/alloc/realloc、new/new[]申请空间，通过free、delete/delete[]释放所申请的空间。由低地址想高地址扩展。

## 14.模板特化、偏特化，萃取 traits 技巧

# STL基础

## 1.选择合适的STL容器

* 根据容器自身性质和数据组织方式可以分为两类：序列容器（vector,deque,list,string）和关联容器（set,map）。
* vector：元素保存在一片连续的内存空间中，就像一个动态数组。
* deque：双端队列，可以在deque两端高效添加和删除元素。
* list：由双向链表实现，其优势在于在任何位置执行插入和删除动作都非常迅速。
* set/map:以RBTree（红黑树）作为底层容器。

# 其它

## 1.Go 的 GC 机制

## 2.三色标记算法的原理

## 3.半连接是什么？

## 4.粘包是什么？怎么发送的？

## 5.怎么创建索引？

## 6.怎么避免缓存击穿？

## 7.Go的mutx怎么使用？

## 8.乐观和悲观锁的实现及使用场景？

## 9.服务器受到攻击怎么定位服务器的问题？

## 10.RPC的具体实现

## 11.谈谈epoll和select

## 12.Go的调度

## 13.Go struct能不能比较

## 14.go defer（for defer）

## 15.select可以用于什么？

## 16.context包的用途

## 17.client如何实现长连接

## 18.主协程如何等待其余协程执行完再操作

## 19.slice,len,cap,共享，扩容

## 20.map如何顺序读取

## 21.实现set

## 22.实现消息队列（多生产者，多消费者）

## 23.大文件排序

## 24.http

## 25.http状态码

## 26.http keep-alive

## 27.tcp与udp的区别，udp的有点及适用场景

## 28.孤儿进程，僵尸进程

## 29.死锁及如何避免

## 30.micro服务发现

## 31.mysql底层有哪几种实现方式

## 32.channel底层实现

## 33.读写锁的底层实现

## 34.raft算法



















