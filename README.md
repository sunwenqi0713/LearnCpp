# C++基础

## 1.简单说一下C++的继承，封装和多态

* 封装：将一个模块的内部数据或操作隐藏起来，其他程序只能通过该模块提供的公开操作来访问他们的保护措施称为信息隐藏。而将这一组数据与这些数据上的相关操作组织在一起的措施称为封装。
* 继承：在一个或若干个已知类的基础上，经过适当的修改，扩充构成一个新类，该类具有原来作为基础的类的特征。
* 多态：在程序中同一符号或名字在不同的情况下具有不同解释的现象称为多态性。编译时多态：通过重载机制获得，包括函数重载和运算符重载；运行时多态：通过继承结合虚函数的动态绑定获得。

## 2.虚函数和虚表

* 虚函数：在一个类中用保留字Virtual定义的成员函数。
* 虚表：虚函数表里是函数指针，指向虚函数的指针。就是C++编译器实现运行时多态的封装。

## 3.什么时候和为什么要用虚析构

首先什么是虚析构，虚析构就是析构函数为虚函数。
那么为什么要用虚析构呢，是为了delete基类指针指向派生类时防止子类得数据不会被释放造成内存泄露。

## 4.纯虚函数

在基类中声明但又没有定义的虚函数。

## 5.函数重载(overload)和函数重写(override)

* 函数重载：在声明函数原型时形参的个数不同或者相同个数的参数但对应位置的参数类型不同，两个或多个函数可以共用同一个名字。
* 函数重写：即重定义，意思是在派生类中定义一个函数原型与继承成员一模一样的成员函数。

## 6.引用与指针的区别

* 初始化要求不同。引用在创建的同时必须初始化，即引用到一个有效的对象；而指针在定义的时候不要求初始化，可以在定义后面的任何地方重新赋值。
* 可修改性不同。引用一旦被初始化为指向一个对象，他就不能被改变为另一个对象的引用；而指针在任何时候都可以改变为指向另一个对象。
* 不存在NULL的引用，它必须总是指向某个对象；指针可以是NULL，不需要总是指向某些对象。

## 7.深拷贝与浅拷贝

* 深拷贝与浅拷贝最本质的区别在于是否真正获取到一个对象的复制实体，而不是引用。
* 浅拷贝只是复制指向某个对象的指针，而不是复制对象本身，新旧对象还是共享同一块内存。
* 深拷贝会创造一个一模一样的对象，新对象与原对象不共享内存，修改新对象不会改变原对象的值。

## 8.new和delete(new[] 和 delete [])

## 9.智能指针以及智能指针的实现，引用计数、RAII（资源获取即初始化）思想

* 智能指针的基本思想就是以栈对象管理资源，在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。引用计数是为了防止内存泄露而产生的，基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。
* unique_ptr: 它对对象持有独有权，两个unique_ptr不能指向同一个对象，不共享其管理的对象，无法复制到其他unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何STL算法，只能移动unique_ptr，对资源管理权实现转移，原始的unique_ptr不再拥有此资源。
* shared_ptr:允许多个指针指向同一个对象，其利用引用计数的方式实现了对所管理的对象所有权的分享，允许多个shared_ptr共同管理同一个对象。
* weak_ptr:可以从一个shared_ptr或者另一个weak_ptr对象构造而来，最大的作用在于协助shared_ptr工作，可获得资源得观测权，只是对shared_ptr 的引用，不改变其引用计数，当被观察的shared_ptr 失效后，相应的weak_ptr也会失败。

## 10.const的使用

## 11.static的使用

## 12.string的实现（实现构造、析构、拷贝构造、赋值操作符）

## 13.编译链接机制、内存布局（memory layout）、对象模型

* 编译链接阶段主要分为预处理、编译、汇编、链接这几个阶

  1、预处理（preprocessor）：对#include、#define、#ifdef/#endif、#ifndef/#endif等进行处理 ;
  2、编译（compiler）：将源码编译为汇编代码 ;
  3、汇编（assembler）：将汇编代码汇编为目标代码 ;
  4、链接（linker）：将目标代码链接为可执行文件 ;

* 可执行程序中的变量在内存中的布局可以总结为如下：

  变量（函数外）：如果未初始化，则存放在BSS段；否则存放在data段

  变量（函数内）：如果没有指定static修饰符，则存放在栈中；否则同上

  常量：存放在文本段.text

  函数参数：存放在栈或寄存器中

  内存可以分为以下几段：

  文本段：包含实际要执行的代码（机器指令）和常量。它通常是共享的，多个实例之间共享文本段。文本段是不可修改的。

  初始化数据段：包含程序已经初始化的全局变量，.data。

  未初始化数据段：包含程序未初始化的全局变量，.bbs。该段中的变量在执行之前初始化为0或NULL。

  栈：由系统管理，由高地址向低地址扩展。

  堆：动态内存，由用户管理。通过malloc/alloc/realloc、new/new[]申请空间，通过free、delete/delete[]释放所申请的空间。由低地址想高地址扩展。

## 14.模板特化、偏特化，萃取 traits 技巧

# STL基础

## 1.选择合适的STL容器

* 根据容器自身性质和数据组织方式可以分为两类：序列容器（vector,deque,list,string）和关联容器（set,map）。
* vector：元素保存在一片连续的内存空间中，就像一个动态数组。
* deque：双端队列，可以在deque两端高效添加和删除元素。
* list：由双向链表实现，其优势在于在任何位置执行插入和删除动作都非常迅速。
* set/map:以RBTree（红黑树）作为底层容器。

# 其它

## 1.Golang 的 GC 机制

经典的GC算法：引用计数（reference counting），标记-清扫（mark&sweep）和复制收集（Copy and Collection）。

Golang的GC算法主要是基于标记-清扫（mark&sweep）算法，并在此基础上做了改进。第一步，找出不可达的对象，然后做上标记。 第二步，回收标记好的对象。算法在执行的时候，需要程序暂停，标记完了之后，然后开始清除未标记的对象，最后，停止暂停，让程序继续跑。然后循环重复这个过程，直到process生命周期结束。

标记-清扫(Mark And Sweep)算法这种算法虽然非常的简单，但是还存在一些问题：

- STW，stop the world；让程序暂停，程序出现卡顿。
- 标记需要扫描整个heap
- 清除数据会产生heap碎片

## 2.三色标记算法的原理

首先：程序创建的对象都标记为白色。扫描所有可到达的对象，标记为灰色。从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色。监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在。此时，gc回收白色对象。最后，将所有黑色对象变为白色，并重复以上所有过程。

## 3.半连接是什么？

TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

 **三次握手：**

 1、第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

 2、第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

 3、第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

 **四次挥手：**

 1、客户端向服务器发送一个FIN为1 的TCP报文

 2、服务器返回给客户端一个确认ACK报文

 3、服务器同时发送一个FIN报文

 4、客户机回复ACK报文后（四次挥手），连接结束。

## 4.粘包是什么？怎么发送的？

所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。

此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。

只有TCP有粘包现象，UDP永远不会粘包。发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提取数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。

粘包的两种情况：一是发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包）；二是接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）。

解决粘包问题：问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据。

## 5.怎么创建索引？

* 使用 CREATE INDEX 语句。

* 使用 CREATE TABLE 语句。索引也可以在创建表（CREATE TABLE）的同时创建。在 CREATE TABLE 语句中添加以下语句。语法格式：CONSTRAINT PRIMARY KEY [索引类型] (<列名>,…)

* 使用 ALTER TABLE 语句。语法格式：ADD INDEX [<索引名>] [<索引类型>] (<列名>,…)

## 6.怎么避免缓存击穿？

* **缓存穿透**

​    缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

   **解决方案：**

1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击

* **缓存击穿**

   缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

   **解决方案：**

1. 设置热点数据永远不过期。
2. 加互斥锁

* **缓存雪崩**

   缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，    缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

   **解决方案**：

1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
3. 设置热点数据永远不过期。

## 7.Golang的mutx怎么使用？

Mutex 用于提供一种加锁机制（Locking Mechanism），可确保在某时刻只有一个协程在临界区运行，以防止出现竞态条件。

Go中使用sync.Mutex类型实现mutex(排他锁、互斥锁)。

通过sync.Mutex类型的两个方法sync.Lock()和sync.Unlock()函数来完成的，前者用于获取sync.Mutex锁，后者用于释放sync.Mutex锁。sync.Mutex一旦被锁住，其它的Lock()操作就无法再获取它的锁，只有通过Unlock()释放锁之后才能通过Lock()继续获取锁。

## 8.乐观和悲观锁的实现及使用场景？

* 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。
* 乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量。**

## 9.服务器受到攻击怎么定位服务器的问题？

* 断开所有的网络连接。
* 根据日志查找攻击者和分析系统漏洞。
* 备份数据和导入安全的数据。

## 10.RPC的具体实现

RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。主要过程：1.建立通信；2.服务寻址；3.网络传输。

## 11.谈谈epoll和select

* select==>时间复杂度O(n)

它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以**select具有O(n)的无差别轮询复杂度**，同时处理的流越多，无差别轮询时间就越长。

* poll==>时间复杂度O(n)

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， **但是它没有最大连接数的限制**，原因是它是基于链表来存储的.

* epoll==>时间复杂度O(1)

**epoll可以理解为event poll**，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是**事件驱动（每个事件关联上fd）**的，此时我们对这些流的操作都是有意义的。**（复杂度降低到了O(1)）**

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。**但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 

epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。

## 12.Go的调度

G 代表一个Goroutine；存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等；另外G对象是可以重用的。

M 代表一个操作系统的线程；M代表着真正的执行计算资源。在绑定有效的p后，进入schedule循环；而schedule循环的机制大致是从各种队列、p的本地队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到m，如此反复。M并不保留G状态，这是G可以跨M调度的基础。

P 代表一个逻辑CPU处理器（在golang中这个是一个对cpu的抽象），通过runtime.GOMAXPROCS (numLogicalProcessors)可以控制多少P，但是通常P的数量设置是等于CPU核数（GOMAXPROCS）。P的数量决定了系统内最大可并行的G的数量（前提：系统的物理cpu核数>=P的数量）；P的最大作用还是其拥有的各种G对象队列、链表、一些cache和状态。

## 13.Go struct能不能比较

如果结构体的所有成员变量都是可比较的，那么结构体就可比较；

如果结构体中存在不可比较的成员变量，那么结构体就不能比较。

如果含有slice或者map，则结构体的实例也不能比较。

## 14.go defer（for defer）

用于注册延迟调用，这些调用直到return前才被执行。多个defer语句，按先进后出的方式执行，defer语句中的变量，在defer声明时就决定了。

可以用来关闭文件句柄，锁资源释放，数据库连接的释放等。

for循环里面的defer：会打开大量的文件。改进方法： defer 移到函数里面。

## 15.select可以用于什么？

select 语句用于在多个发送/接收信道操作中进行选择。select语句会一直阻塞，直到发送/接收操作准备就绪。如果有多个信道操作准备完毕，select会随机地选取其中之一执行。该语法与 switch 类似，所不同的是，这里的每个case语句都是信道操作。

select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。

## 16.context包的用途

context 包定义了一个 Context （上下文）类型，可以在 Api 之间和进程之间传递信息，还提供了超时（timeout）和取消（cancel）机制。

Go 标准库中，database/sql，net，net/http 等包中都使用了 Context。

在 Go 应用开发中，一般用于请求链路中传递上下文信息，控制子 goroutine 等场景中。

## 17.client如何实现长连接

方法：“Connection”："keep-alive"

当我们向一台服务器发起请求时，我们需要和对方建立一条通道，去传输数据，所谓的短连接，就是说我们建立起了通道，然后在传输完数据，就把通道摧毁，下次需要的时候再重新去建立通道。长连接呢，就是指，我们建立了一条通道，传递完数据后，先不摧毁，下次如果还需要传输数据，就复用这条通道。因为通道的建立是需要花费时间的，所以长连接的优势就在于响应速度快，但是服务器压力大，因为同时有很多人在向服务器建立通道，即便有些通道已经传输完数据了，由于长连接的原因，通道也不会被摧毁；短连接呢，则是，响应速度慢，服务器压力小。由于现在更多的是强调用户的体验，所以长连接目前是最常见的。

## 18.主协程如何等待其余协程执行完再操作

* 使用channel同步
* 使用sync.WaitGroup

## 19.slice,len,cap,共享,扩容

* slice：一个指向底层的数组的指针结构体。
* len：slice中元素的数量。
* cap：slice占用内存数量（即容量）。
* 共享：slice有个特性是允许多个slice指向同一个底层数组，这是一个有用的特性，在很多场景下都能通过这个特性实现 no copy 而提高效率。但共享同时意味着不安全。
* 扩容：当切片长度超过容量时，底层数组会重新分配内存空间，那么append会指向新切片

## 20.map如何顺序读取

map是一种无序的key-value数据结构，使用for-range语句就可以遍历。当需要按序打印输出，可以把map中的对应数据拷贝到切片里，使用sort包里的排序函数进行排序。

## 21.实现set

通过 map 实现 set，map 的 key 肯定是唯一的，设置 value 为空结构体。

## 22.实现消息队列（多生产者，多消费者）

我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ

## 23.大文件排序

内存极少的情况下，利用分治策略，利用外存保存中间结果，再用多路归并来排序

## 24.http请求方法及请求首部

* Get，Post，Put，Delete，Head，Trace，Options等

* 首部字段：

  Accept：客户端在HTTP响应中能够接收的内容类型，例如：text/html;

  Accept-Charset：客户端要求服务器使用的字符集编码；

  Authorization：用于向服务器发送基本的身份验证证书；

  Cookie：某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息；

  Content-Length：请求主体的字节长度；

  Content-type：用于记录请求主体的内容的类型；

  Host：服务器的名字以及端口号；

  Referrer：发起请求的页面所在的地址；

  User-Agent：对发起请求的客户端进行描述；

## 25.http状态码

1XX：情报状态码。

2XX：成功状态码。

3XX：重定向状态码。大多用于实现URL重定向。

4XX：客户端错误状态码。

5XX：服务器错误状态码。

## 26.http keep-alive

## 27.tcp与udp的区别，udp的优点及适用场景

* TCP面向连接；UDP是无连接的，即发送数据之前不需要建立连接；
* TCP提供可靠的服务，通过TCP传送的数据，无差别，不丢失，不重复，且按序到达；UDP尽最大努力交付，不保证可靠交付；
* UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信；
* 每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信；
* TCP对系统资源要求较多，UDP对系统资源要求较少；

UDP以其简单、传输快的优势，在越来越多场景下取代了TCP，如实时游戏。

（1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。

（2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。

采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。

## 28.孤儿进程，僵尸进程，守护进程

* **孤儿进程**指的是在其父**进程**执行完成或被终止后仍继续运行的一类**进程**；
* **僵尸进程**是指完成执行（通过 exit 系统调用，或运行时发生致命错误或收到终止信号所致）但在操作系统的**进程**表中仍然有一个表项（**进程**控制块PCB），处于"终止状态 "的**进程**；
* **守护进程**（英语：daemon）是一种在后台执行的电脑程序。 此类程序会被以**进程**的形式初始化。 **守护进程**程序的名称通常以字母“d”结尾：例如，syslogd就是指管理系统日志的**守护进程**。

## 29.死锁及如何避免

所谓死锁<DeadLock>：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁。

- 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
- 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
- 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

## 30.micro服务发现

服务发现的关键是服务注册表，服务注册表是可用服务实例的数据库，它提供了管理和查询使用的API。服务实例使用这些管理API进行服务的注册和注销，系统组件使用查询API来发现可用的服务实例。

有两种服务发现的模式：客户端发现和服务端发现。在使用客户端发现模式的系统中，客户端直接查询服务注册表，选择一个可用的实例并发起请求，在一个使用服务端发现模式的系统中，客户端通过路由发起请求，路由会查询服务注册表并把请求转发到可用的服务实例上。

## 31.mysql底层有哪几种实现方式

InnoDB 和 Myisam 都是用 B+Tree 来存储数据的

## 32.channel底层实现

对 chan 的发送和接收操作都会在编译期间转换成为底层的发送接收函数。

Channel 分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作“同步模式”，带缓冲的则称为“异步模式”。

同步模式下，发送方和接收方要同步就绪，只有在两者都 ready 的情况下，数据才能在两者间传输（后面会看到，实际上就是内存拷贝）。否则，任意一方先行进行发送或接收操作，都会被挂起，等待另一方的出现才能被唤醒。

异步模式下，在缓冲槽可用的情况下（有剩余容量），发送和接收操作都可以顺利进行。否则，操作的一方（如写入）同样会被挂起，直到出现相反操作（如接收）才会被唤醒。

小结一下：同步模式下，必须要使发送方和接收方配对，操作才会成功，否则会被阻塞；异步模式下，缓冲槽要有剩余容量，操作才会成功，否则也会被阻塞。

## 33.读写锁的底层实现

互斥锁和条件变量

## 34.raft算法

Raft是一种共识算法。

Raft通过领导方法实现共识。该集群只有一个当选的领导者，负责管理集群其他服务器上的日志复制。这意味着领导者可以决定新条目的放置和在其与其他服务器之间建立数据流而无需咨询其他服务器。领导者领导，直到失败或断开连接，在这种情况下，新的领导者当选。

## 35.防止goroutine泄露

* 通过 runtime.NumGoroutine() 获取当前运行中的 goroutine 数量，通过它确认是否发生泄漏。
* chanel引起的泄露：发送不接收（需要一种机制去通知发送者，Go 可以通过 channel 的关闭向所有的接收者发送广播信息，例如通过 select 实现 2 个 channel 的同时处理。当异常发生时，将进入 <-done 分支，实现 goroutine 退出）和接收不发送（发送完成后一定要记得关闭 channel），向 nil channel 发送和接收数据都将会导致阻塞。这种情况可能在我们定义 channel 时忘记初始化的时候发生。
* 因为 Go 有 defer 的存在，这个问题还是非常容易解决的，只要记得在 Lock 的时候，记住 defer Unlock 即可。
* WaitGroup 和锁有所差别，它类似 Linux 中的信号量，可以实现一组 goroutine 操作的等待。使用的时候，如果设置了错误的任务数，也可能会导致阻塞，导致泄露发生。建议是，尽量不要一次设置全部任务数，即使数量非常明确的情况。因为在开始多个并发任务之间或许也可能出现被阻断的情况发生。最好是尽量在任务启动时通过 wg.Add(1) 的方式增加。

## 36.make和new



## 37.TODO























